#!/usr/bin/python3

import sys
import re

class Context:
    def __init__(self):
        self.lineno = 0
        self.charno = 0
        self.colno  = 0
        self.colidx = 0

class Event:
    LineEnd    = 'le'
    Macro      = 'm'  # (macro)
    GroupBegin = 'gb' # (depth)
    GroupEnd   = 'ge' # (depth)
    TextBegin  = 'tb' # (text begin string)
    TextEnd    = 'te' # (text end string)

    def __init__(self, e, context, *args):
        self.name = e
        self.context = context
        self.args = args

class LineLength:
    def __init__(self, linter, parser, max_len):
        self.linter = linter
        self.max_len = max_len

        parser.register(Event.LineEnd, self.handler)

    def handler(self, event):
        if event.context.colno > self.max_len:
            self.linter.l("Line {} exceeds {} characters limit.".format( \
              event.context.lineno, self.max_len))

class EqIndentation:
    def __init__(self, linter, parser, indent):
        self.linter = linter
        self.indent = indent

        self.expect = False
        self.depth = None
        self.equation = False

        parser.register(Event.Macro, self.macro)
        parser.register(Event.GroupBegin, self.group_begin)
        parser.register(Event.GroupEnd, self.group_end)
        parser.register(Event.TextBegin, self.text_begin)

    def macro(self, event):
        if event.args[0] == 'eq':
            self.expect = True

    def group_begin(self, event):
        if not self.expect:
            return
        self.expect = False

        self.depth = event.args[0]
        self.equation = True

    def group_end(self, event):
        if self.depth != event.args[0]:
            return

        self.depth = None
        self.equation = False

    def text_begin(self, event):
        if not self.equation:
            return

        if not event.args[0].startswith(self.indent):
            self.linter.l("Wrong equation indentation on line {}".format( \
              event.context.lineno))
        
# XXX Such checker would be much easier written as regular expression
#     (However, this takes comment into account too.)
class TrailingWhitespace:
    def __init__(self, linter, parser):
        self.linter = linter

        parser.register(Event.TextEnd, self.text_end)

    def text_end(self, event):
        text = event.args[0]
        if len(text) == 0:
            return

        if text[-1].isspace():
            self.linter.l("Trailing whitespace on line {}".format( \
              event.context.lineno))
        

class Linter:
# TODO could print context neighborhood
    def l(self, message):
        print(message)

class Parser:
    seq = re.compile('[a-zA-Z0-9_]')

    STATE_TEXT    = 1
    STATE_SEQ     = 2
    STATE_COMMENT = 3
        
    def __init__(self):
        self.handlers = {}

        self.fsm = {
            self.STATE_TEXT:    self._st_text,
            self.STATE_SEQ:     self._st_seq,
            self.STATE_COMMENT: self._st_comment,
        }
            
    def register(self, e, handler):
        if not e in self.handlers:
            self.handlers[e] = []
        self.handlers[e].append(handler)


    def parse(self, stream):
        self.depth = 0
        self.macro = None
        self.context = Context()

        for line in stream:
            self.state = self.STATE_TEXT
            self.context.lineno += 1
            self.context.colno = 0
            begin = True
            line = line[:-1] # TODO CRLF

            for c in line:
                self.context.colidx = self.context.colno
                self.context.colno += 1
                self.context.charno += 1

                ps = self.state
                s = self.fsm[self.state](line,c)
                self.state = s if s else self.state

                if begin and self.state != self.STATE_COMMENT:
                    self._raise(Event.TextBegin, line[self.context.colidx:])
                elif self.state != ps and self.state == self.STATE_COMMENT:
                    self._raise(Event.TextEnd, line[:self.context.colidx])

                begin = False

            if self.state != self.STATE_COMMENT:
                self._raise(Event.TextEnd, line[:self.context.colidx + 1])

            self._raise(Event.LineEnd)

    def _raise(self, e, *args):
        #print("Raise: {}".format(e), args)
        if not e in self.handlers:
            return

        event = Event(e, self.context, *args)
        for h in self.handlers[e]:
            h(event)

    def _st_text(self, line, c):
        if c == '\\':
            self.macro = self.context.colidx + 1
            return self.STATE_SEQ
        elif c == '{':
            self.depth += 1
            self._raise(Event.GroupBegin, self.depth)
        elif c == '}':
            self._raise(Event.GroupEnd, self.depth)
            self.depth -= 1
        elif c == '%':
            return self.STATE_COMMENT

    def _st_seq(self, line, c):
        if self.seq.match(c):
            return self.STATE_SEQ
        else:
            macro = line[self.macro:self.context.colidx]
            self._raise(Event.Macro, macro)
            self.state = self.STATE_TEXT
            return self._st_text(line, c)

    def _st_comment(self, line, c):
        # comment is turned of in main loop
        pass


if __name__ == '__main__':
    p = Parser()
    l = Linter()

    LineLength(l, p, 80)
    EqIndentation(l, p, '    ')
    TrailingWhitespace(l, p)

    p.parse(sys.stdin)

